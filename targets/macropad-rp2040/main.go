package main

import (
	_ "embed"
	"fmt"
	"image/color"
	"log"
	"machine"
	"machine/usb"
	"time"

	keyboard "github.com/sago35/tinygo-keyboard"
	"github.com/sago35/tinygo-keyboard/keycodes/jp"
	"tinygo.org/x/drivers/sh1106"
	"tinygo.org/x/drivers/ws2812"
	"tinygo.org/x/tinyfont"
	"tinygo.org/x/tinyfont/freemono"
)

//go:embed vial.json
var def []byte

func main() {
	usb.Product = "macropad-rp2040-0.1.0"

	err := run()
	if err != nil {
		log.Fatal(err)
	}
}

var (
	white = color.RGBA{0xFF, 0xFF, 0xFF, 0xFF}
	black = color.RGBA{0x00, 0x00, 0x00, 0xFF}
)

func run() error {
	machine.SPI1.Configure(machine.SPIConfig{
		Frequency: 48000000,
	})
	display := sh1106.NewSPI(machine.SPI1, machine.OLED_DC, machine.OLED_RST, machine.OLED_CS)
	display.Configure(sh1106.Config{
		Width:  128,
		Height: 64,
	})
	display.ClearDisplay()

	neo := machine.WS2812
	neo.Configure(machine.PinConfig{Mode: machine.PinOutput})
	ws := ws2812.New(neo)
	wsLeds := [12]color.RGBA{}
	for i := range wsLeds {
		wsLeds[i] = black
	}

	d := keyboard.New()

	gpioPins := []machine.Pin{
		machine.KEY1,
		machine.KEY2,
		machine.KEY3,
		machine.KEY4,
		machine.KEY5,
		machine.KEY6,
		machine.KEY7,
		machine.KEY8,
		machine.KEY9,
		machine.KEY10,
		machine.KEY11,
		machine.KEY12,
	}

	for c := range gpioPins {
		gpioPins[c].Configure(machine.PinConfig{Mode: machine.PinInputPullup})
	}

	gk := d.AddGpioKeyboard(gpioPins, [][]keyboard.Keycode{
		{
			jp.Key1,
			jp.Key2,
			jp.Key3,
			jp.Key4,
			jp.Key5,
			jp.Key6,
			jp.Key7,
			jp.Key8,
			jp.Key9,
			jp.KeyA,
			jp.KeyB,
			jp.KeyC,
		},
	})
	gk.SetCallback(func(layer, index int, state keyboard.State) {
		row := index / 3
		col := index % 3
		fmt.Printf("gk: %d %d %d %d %d\n", layer, index, row, col, state)
		c := white
		wsLeds[index] = white
		if state == keyboard.PressToRelease {
			wsLeds[index] = black
			c = black
		}
		display.ClearBuffer()
		tinyfont.WriteLine(&display, &freemono.Regular9pt7b, 10, 20, fmt.Sprintf("Key%d", index+1), c)
		display.Display()
	})

	rk := d.AddRotaryKeyboard(machine.ROT_A, machine.ROT_B, [][]keyboard.Keycode{
		{
			jp.KeyMediaVolumeDec, jp.KeyMediaVolumeInc,
		},
	})
	rk.SetCallback(func(layer, index int, state keyboard.State) {
		fmt.Printf("rk: %d %d %d\n", layer, index, state)
	})

	// for Vial
	keyboard.KeyboardDef = []byte{0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00, 0x00, 0x04, 0xE6, 0xD6, 0xB4, 0x46, 0x02, 0x00, 0x21, 0x01, 0x16, 0x00, 0x00, 0x00, 0x74, 0x2F, 0xE5, 0xA3, 0xE0, 0x00, 0xF9, 0x00, 0xA8, 0x5D, 0x00, 0x3D, 0x88, 0x89, 0xC6, 0x54, 0x36, 0xC3, 0x17, 0x4F, 0xE4, 0xFA, 0x84, 0x23, 0x76, 0xB7, 0xFC, 0x71, 0xB1, 0x70, 0x43, 0x0F, 0xA5, 0x54, 0x12, 0xA5, 0xD8, 0x8D, 0x50, 0x52, 0x70, 0xAC, 0xC3, 0x82, 0x76, 0x6A, 0xF5, 0xB7, 0x41, 0x11, 0x7F, 0x8B, 0x33, 0xD1, 0x2E, 0xCC, 0xB2, 0xD2, 0x19, 0x61, 0x1B, 0xB6, 0x94, 0x43, 0x0F, 0x86, 0xDD, 0x6D, 0xC8, 0x01, 0xA5, 0x5F, 0x63, 0xEB, 0x29, 0xB5, 0xC5, 0x73, 0x3D, 0x1B, 0x24, 0x11, 0xDF, 0x5E, 0xDC, 0x06, 0xA7, 0xDB, 0x8F, 0x1F, 0x1B, 0xDC, 0xFD, 0x86, 0xEA, 0x03, 0x04, 0x49, 0xB6, 0x55, 0x93, 0x64, 0x6F, 0x66, 0x75, 0xDB, 0x53, 0xE9, 0x77, 0x00, 0x59, 0x37, 0x47, 0x76, 0xA7, 0x34, 0x87, 0x57, 0x85, 0x9B, 0x58, 0xA1, 0x21, 0xD9, 0xED, 0xC8, 0xE2, 0xA2, 0xC4, 0xD6, 0xFA, 0x3F, 0x78, 0x61, 0xBF, 0x32, 0x06, 0xAF, 0x28, 0x12, 0xF1, 0x84, 0xFE, 0x9E, 0xDB, 0x63, 0xF0, 0x45, 0x29, 0xC7, 0x5F, 0xC3, 0x92, 0xF6, 0xC1, 0x5C, 0x25, 0xCA, 0xD1, 0x4C, 0x3A, 0x2D, 0xB5, 0xDC, 0xFA, 0xA3, 0x66, 0xDA, 0x68, 0x0C, 0xC4, 0xFA, 0xE4, 0xAE, 0x88, 0x47, 0x0E, 0xB9, 0x3A, 0x00, 0x87, 0x62, 0x9D, 0xCB, 0x28, 0x68, 0x7E, 0xF9, 0x00, 0x01, 0xC4, 0x01, 0xFA, 0x01, 0x00, 0x00, 0x3B, 0x3D, 0x55, 0x9C, 0xB1, 0xC4, 0x67, 0xFB, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x59, 0x5A}

	err := d.Init()
	if err != nil {
		return err
	}

	cont := true
	for cont {
		err := d.Tick()
		if err != nil {
			return err
		}
		ws.WriteColors(wsLeds[:])
		time.Sleep(10 * time.Millisecond)
	}

	return nil
}
